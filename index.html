<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>OSM Completeness Helper - Fast & Interactive</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<style>
  .legend i { display: inline-block; width: 18px; height: 18px; margin-right: 8px; opacity: 0.7; }
  .highlight-row { background-color: #fffa65 !important; }
  .highlight-feature { weight: 4 !important; color: red !important; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #ccc; padding: 4px; font-size: 0.9rem; text-align: left; }
  th { background-color: #f0f0f0; }
</style>
</head>

<body class="bg-gray-100 text-gray-800">
<div class="max-w-5xl mx-auto p-5">

<h1 class="text-center text-3xl font-bold text-red-900 mb-6">OSM Completeness Helper</h1>

<!-- ======================== UI EXPLANATION PANEL ======================== -->
<div class="bg-yellow-100 border-l-4 border-yellow-600 p-4 rounded mb-6">
  <h2 class="text-xl font-bold mb-2 text-yellow-800">üìò How Priorities Are Calculated</h2>
  <p class="mb-3">
    This tool helps volunteers focus on the <strong>most impactful areas</strong> for mapping.  
    Two key scores are computed for each area:
  </p>

  <h3 class="font-semibold text-yellow-900">1Ô∏è‚É£ Building Workload Score (BWS)</h3>
  <p class="mb-2 pl-4">
    BWS estimates <strong>how many buildings are missing</strong> from OpenStreetMap.  
    It uses:
  </p>
  <ul class="list-disc pl-10 text-sm mb-4">
    <li>Area size (km¬≤)</li>
    <li>Typical building density of the region</li>
    <li>Building unmapped percent</li>
  </ul>

  <p class="mb-4 pl-4 text-sm">
    <strong>Higher BWS = More buildings missing = Higher priority.</strong>
  </p>

  <h3 class="font-semibold text-yellow-900">2Ô∏è‚É£ Operational Priority Score (OPS)</h3>
  <p class="mb-2 pl-4">
    OPS combines:
  </p>
  <ul class="list-disc pl-10 text-sm mb-4">
    <li>70% BWS (real workload for volunteers)</li>
    <li>30% Population Density (more people potentially affected)</li>
  </ul>

  <p class="pl-4 font-semibold">
    üìå <strong>OPS Selects the Best Target for Volunteer Time</strong>
  </p>

  <p class="text-xs mt-4 opacity-70">
    *This explanation is simplified intentionally to help first-time users understand the logic without GIS background.*
  </p>
</div>
<!-- ===================================================================== -->


<!-- Step 1 Upload -->
<div class="bg-white p-5 rounded-lg shadow mb-5">
  <h2 class="text-xl font-semibold mb-3">Step 1: Upload or Paste GeoJSON</h2>
  <div id="upload-container" class="border-2 border-dashed border-red-800 rounded-lg p-6 text-center bg-white mb-3">
    <p class="mb-2">Drag & drop your GeoJSON file here</p>
    <p class="mb-2">OR</p>
    <input type="file" id="file-input" accept=".geojson,.json" class="hidden" />
    <button id="file-select-btn" class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded mb-2">Select File</button>
    <p class="mb-2">OR paste GeoJSON text below:</p>
    <textarea id="geojson-text" placeholder="Paste your GeoJSON here..." class="w-full h-32 p-2 border border-gray-300 rounded mb-2 font-mono"></textarea>
  </div>

  <button id="split-btn" class="bg-blue-800 hover:bg-blue-700 text-white py-2 px-4 rounded mb-2 w-full">Split Multi-Areas ‚Üí Single Areas</button>
  <button id="process-btn" class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded mb-2 w-full" disabled>Process GeoJSON</button>
  <button id="download-btn" class="bg-green-800 hover:bg-green-700 text-white py-2 px-4 rounded w-full" disabled>Download Processed GeoJSON</button>
  <div id="loader" class="w-8 h-8 border-4 border-gray-300 border-t-red-800 rounded-full animate-spin mx-auto hidden mt-2"></div>
</div>

<!-- Tabs -->
<div class="flex space-x-2 mb-4">
  <button class="tab active px-4 py-2 bg-red-800 text-white rounded-t" data-tab="map-tab">Map View</button>
  <button class="tab px-4 py-2 bg-red-200 text-red-800 rounded-t" data-tab="table-tab">Table View</button>
</div>

<!-- MAP TAB -->
<div id="map-tab" class="tab-content">
  <div class="bg-white p-4 rounded-lg shadow mb-4 flex flex-col sm:flex-row items-center">
    <label for="metric-selector" class="mr-2 font-medium">Color Map By:</label>
    <select id="metric-selector" class="p-2 border border-gray-300 rounded mt-2 sm:mt-0"></select>
  </div>

  <div id="map" class="h-[500px] rounded-lg mb-4"></div>
  <div class="bg-white p-4 rounded-lg shadow text-center">
    <strong>Map Legend:</strong> Color shows the chosen metric (darker = higher value)
  </div>
</div>

<!-- TABLE TAB -->
<div id="table-tab" class="tab-content hidden">
  <div class="bg-white p-5 rounded-lg shadow">
    <h2 class="text-2xl font-semibold mb-4">GeoJSON Data Table</h2>
    <div id="table-container">
      <p>Process a GeoJSON file to see its data in a table here.</p>
    </div>
  </div>
</div>

<footer class="text-center mt-8 text-sm text-gray-600">
  Developed with ‚ù§Ô∏è by <a href="https://github.com/kshitijrajsharma/" class="text-red-800 font-semibold" target="_blank">Kshitij Raj Sharma</a> & Disaster Ninja API
</footer>

<!-- LEAFLET -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

<script>
let map, geoJsonLayer, originalGeoJson=null, processedGeoJson=null, currentMetric="ops_score";
let originalFileName = "geojson";
let featureIdCounter = 0;

/* --- SPLIT MULTIPARTS --- */
function splitGeoJSONToSinglepart(geojson){
  let features=[];

  const addFeature = (feature)=>{
    if(!feature.geometry) return;

    switch(feature.geometry.type){
      case "MultiPolygon":
        feature.geometry.coordinates.forEach(coords=>{
          features.push({type:"Feature", properties:{...feature.properties}, geometry:{type:"Polygon", coordinates:coords}, _fid:featureIdCounter++});
        });
        break;
      default:
        features.push({...feature, _fid: featureIdCounter++});
    }
  };

  if(geojson.type==="FeatureCollection") geojson.features.forEach(addFeature);
  else if(geojson.type==="Feature") addFeature(geojson);

  return {type:"FeatureCollection", features};
}

/* --- MAP INIT --- */
function initMap(){
  map=L.map("map",{preferCanvas:true}).setView([20,0],2);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

  document.getElementById("metric-selector").addEventListener("change", function(){
    currentMetric=this.value;
    updateMap(processedGeoJson);
  });
}

/* --- DRAG DROP --- */
function initDragAndDrop(){
  const upload=document.getElementById("upload-container");

  upload.addEventListener("dragover", e=>{e.preventDefault();});
  upload.addEventListener("drop", e=>{
    e.preventDefault();
    handleFile(e.dataTransfer.files[0]);
  });

  document.getElementById("file-select-btn")
      .addEventListener("click", ()=>document.getElementById("file-input").click());

  document.getElementById("file-input")
      .addEventListener("change", e=>handleFile(e.target.files[0]));

  document.getElementById("split-btn")
      .addEventListener("click", ()=>{
        processedGeoJson=splitGeoJSONToSinglepart(originalGeoJson);
        document.getElementById("geojson-text").value=
            JSON.stringify(processedGeoJson,null,2);
        alert("GeoJSON split!");
        document.getElementById("process-btn").disabled=false;
  });

  document.getElementById("process-btn").addEventListener("click", processGeoJson);
  document.getElementById("download-btn").addEventListener("click", downloadEnhancedGeoJson);

  document.getElementById("geojson-text")
      .addEventListener("input", function(){
        document.getElementById("process-btn").disabled = !this.value.trim().length;
  });

  document.querySelectorAll(".tab").forEach(tab=>{
    tab.addEventListener("click", function(){
      document.querySelectorAll(".tab").forEach(t=>{
        t.classList.remove("bg-red-800","text-white");
        t.classList.add("bg-red-200","text-red-800");
      });

      document.querySelectorAll(".tab-content")
          .forEach(c=>c.classList.add("hidden"));

      this.classList.add("bg-red-800","text-white");
      document.getElementById(this.dataset.tab).classList.remove("hidden");
    });
  });
}

/* --- HANDLE UPLOAD --- */
function handleFile(file){
  if(!file) return;
  const reader=new FileReader();
  reader.onload=e=>{
    originalGeoJson=JSON.parse(e.target.result);
    document.getElementById("geojson-text").value = JSON.stringify(originalGeoJson,null,2);
    document.getElementById("process-btn").disabled=false;
  };
  reader.readAsText(file);
}

/* --- PROCESSING --- */
async function processGeoJson(){
  processedGeoJson = splitGeoJSONToSinglepart(originalGeoJson);
  const features = processedGeoJson.features;

  // ============== CALL DISASTER NINJA ==============
  for(const f of features){
    if(!(f.geometry && f.geometry.type==="Polygon")) continue;

    try{
      const res = await fetch("https://disaster.ninja/active/api/polygon_details",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({type:"Feature", properties:{}, geometry:f.geometry})
      });

      const data = await res.json();
      if(!f.properties) f.properties={};

      data.forEach(item=>{
        const key=item.name.toLowerCase().replace(/\s+/g,"_");

        if(item.name==="Buildings unmapped"){
          f.properties.building_unmapped_percent = item.percentValue;
        }
        if(item.name==="Population"){
          const m1=item.text.match(/([0-9,]+) people/);
          const m2=item.text.match(/on ([0-9.]+) km2/);
          f.properties.population = m1? parseInt(m1[1].replace(/,/g,"")):0;
          f.properties.area_km2 = m2? parseFloat(m2[1]):0;
          f.properties.population_density = (f.properties.population && f.properties.area_km2)?
                f.properties.population / f.properties.area_km2 : 0;
        }
      });

    }catch(err){
      console.error(err);
    }
  }

  // ========== BWS CALCULATION ==========
  // building density model (very rough but stable for global usage)
  const avgDensity = 300; // buildings/km2 baseline

  features.forEach(f=>{
    const area=f.properties.area_km2||0;
    const bu=f.properties.building_unmapped_percent||0;
    const estMissing = area * avgDensity * (bu/100);
    f.properties.bws_score = Math.round(estMissing);
  });

  // ========== OPS CALCULATION ==========
  features.forEach(f=>{
    const bws = f.properties.bws_score || 0;
    const dens = f.properties.population_density || 0;

    const densNorm = Math.min(dens / 10000, 1);
    const bwsNorm  = Math.min(bws  / 30000, 1);

    const ops = (bwsNorm * 0.7 + densNorm * 0.3) * 100;
    f.properties.ops_score = Math.round(ops*10)/10;
  });

  // BUILD METRIC SELECTOR
  const allKeys = new Set();
  features.forEach(f=>{
    Object.keys(f.properties).forEach(k=>allKeys.add(k));
  });

  const sel=document.getElementById("metric-selector");
  sel.innerHTML="";
  allKeys.forEach(k=>{
    const o=document.createElement("option");
    o.value=k; o.textContent=k.replace(/_/g," ");
    sel.appendChild(o);
  });

  if(allKeys.has("ops_score")) currentMetric="ops_score";
  sel.value=currentMetric;

  updateMap(processedGeoJson);
  updateTable(processedGeoJson);
  document.getElementById("download-btn").disabled=false;
}

/* --- MAP UPDATE --- */
function updateMap(geojson){
  if(geoJsonLayer) map.removeLayer(geoJsonLayer);

  const vals=geojson.features.map(f=>f.properties[currentMetric]||0);
  const min=Math.min(...vals), max=Math.max(...vals);

  const getColor=v=>{
    if(max===min) return "#67000d";
    const t=(v-min)/(max-min);
    return t>0.8?"#67000d":t>0.6?"#a50f15":t>0.4?"#cb181d":t>0.2?"#ef3b2c":"#fb6a4a";
  };

  geoJsonLayer = L.geoJSON(geojson, {
    style:f=>({
      color:getColor(f.properties[currentMetric]),
      weight:2,
      fillOpacity:0.6
    }),
    onEachFeature:(feature,layer)=>{
      layer.bindPopup(
        Object.entries(feature.properties)
              .map(([k,v])=>`<strong>${k}</strong>: ${v}`)
              .join("<br>")
      );
    }
  }).addTo(map);

  map.fitBounds(geoJsonLayer.getBounds());
}

/* --- TABLE UPDATE --- */
function updateTable(geojson){
  const c=document.getElementById("table-container");
  const cols=new Set();
  geojson.features.forEach(f=>Object.keys(f.properties).forEach(k=>cols.add(k)));
  const columns=[...cols];

  let html="<table><thead><tr>";
  columns.forEach(c2=>html+=`<th>${c2}</th>`);
  html+="</tr></thead><tbody>";

  geojson.features.forEach(f=>{
    html+=`<tr>`;
    columns.forEach(k=>html+=`<td>${f.properties[k]||""}</td>`);
    html+="</tr>";
  });

  html+="</tbody></table>";
  c.innerHTML=html;
}

/* --- DOWNLOAD --- */
function downloadEnhancedGeoJson(){
  const blob=new Blob([JSON.stringify(processedGeoJson,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download="processed.geojson";
  a.click();
  URL.revokeObjectURL(url);
}

document.addEventListener("DOMContentLoaded", ()=>{
  initMap();
  initDragAndDrop();
});
</script>
</body>
</html>
