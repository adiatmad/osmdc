<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoJSON Processor</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <!-- Tailwind Browser Version -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      /* Minimal custom style for Leaflet legend icons */
      .legend i {
        display: inline-block;
        width: 18px;
        height: 18px;
        margin-right: 8px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="max-w-6xl mx-auto p-5">
      <h1 class="text-center text-3xl font-bold text-red-900 mb-8">
        OSM Completeness Helper
      </h1>
      <div class="bg-white p-5 rounded-lg shadow mb-5">
        <div
          id="upload-container"
          class="border-2 border-dashed border-red-800 rounded-lg p-10 text-center transition-colors duration-300 bg-white mb-5"
        >
          <p class="mb-2">Drag & drop your GeoJSON file here</p>
          <p class="mb-2">OR</p>
          <input
            type="file"
            id="file-input"
            accept=".geojson,.json"
            class="hidden"
          />
          <button
            id="file-select-btn"
            class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded mb-2"
          >
            Select File
          </button>
          <p class="mb-2">OR</p>
          <p class="mb-2">Paste your GeoJSON text below:</p>
          <p class="mb-2">Make sure CRS is WGS1984</p>

          <textarea
            id="geojson-text"
            placeholder="Paste your GeoJSON here..."
            class="w-full h-40 p-2 border border-gray-300 rounded mb-5 font-mono"
          ></textarea>
        </div>
        <div class="flex flex-wrap gap-2 items-center">
          <button
            id="process-btn"
            class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded"
            disabled
          >
            Process GeoJSON
          </button>
          <button
            id="download-btn"
            class="bg-green-800 hover:bg-green-700 text-white py-2 px-4 rounded"
            disabled
          >
            Download Processed GeoJSON
          </button>
          <div
            id="loader"
            class="w-8 h-8 border-4 border-gray-300 border-t-red-800 rounded-full animate-spin mx-auto hidden"
          ></div>
        </div>
      </div>
      <div class="flex space-x-2 mb-4">
        <button
          class="tab active px-4 py-2 bg-red-800 text-white rounded-t"
          data-tab="map-tab"
        >
          Map View
        </button>
        <button
          class="tab px-4 py-2 bg-red-200 text-red-800 rounded-t"
          data-tab="table-tab"
        >
          Table View
        </button>
      </div>
      <div id="map-tab" class="tab-content">
        <div
          class="bg-white p-4 rounded-lg shadow mb-4 flex flex-col sm:flex-row items-center"
        >
          <label for="metric-selector" class="mr-2 font-medium">
            Color Map By:
          </label>
          <select
            id="metric-selector"
            class="p-2 border border-gray-300 rounded mt-2 sm:mt-0"
          ></select>
        </div>
        <div id="map" class="h-[500px] rounded-lg mb-4"></div>
        <div class="bg-white p-4 rounded-lg shadow text-center">
          <strong>Map Legend:</strong> Colors indicate selected metric (darker =
          higher value)
        </div>
      </div>
      <div id="table-tab" class="tab-content hidden">
        <div class="bg-white p-5 rounded-lg shadow">
          <h2 class="text-2xl font-semibold mb-4">GeoJSON Data</h2>
          <div id="table-container">
            <p>Process a GeoJSON file to view data in table format.</p>
          </div>
        </div>
      </div>
      <!-- Footer with Info Icon -->
      <footer class="text-center mt-8 text-sm text-gray-600">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
          class="w-4 h-4 inline mr-1"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M13 16h-1v-4h-1m1-4h.01M12 2a10 10 0 110 20 10 10 0 010-20z"
          />
        </svg>
        Developed with love by
        <a
          href="https://github.com/kshitijrajsharma/"
          class="text-red-800 font-semibold"
          target="_blank"
          >Kshitij Raj Sharma</a
        >
        with the help of
        <a
          href="https://github.com/konturio/disaster-ninja-be?tab=readme-ov-file"
          class="text-red-800 font-semibold"
          target="_blank"
          >Disaster Ninja API</a
        >.
      </footer>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
      let map,
        geoJsonLayer,
        originalGeoJson = null,
        processedGeoJson = null,
        currentMetric = "osm_gaps_percent";

      function initMap() {
        map = L.map("map").setView([20, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        }).addTo(map);
        document
          .getElementById("metric-selector")
          .addEventListener("change", function () {
            currentMetric = this.value;
            if (processedGeoJson) updateMap(processedGeoJson);
          });
      }

      function initDragAndDrop() {
        const uploadArea = document.getElementById("upload-container");
        uploadArea.addEventListener("dragover", (e) => {
          e.preventDefault();
          uploadArea.classList.add("bg-red-100", "border-red-700");
        });
        uploadArea.addEventListener("dragleave", (e) => {
          e.preventDefault();
          uploadArea.classList.remove("bg-red-100", "border-red-700");
        });
        uploadArea.addEventListener("drop", (e) => {
          e.preventDefault();
          uploadArea.classList.remove("bg-red-100", "border-red-700");
          handleFile(e.dataTransfer.files[0]);
        });
        document
          .getElementById("file-select-btn")
          .addEventListener("click", () =>
            document.getElementById("file-input").click()
          );
        document
          .getElementById("file-input")
          .addEventListener("change", (e) => handleFile(e.target.files[0]));
        document
          .getElementById("process-btn")
          .addEventListener("click", processGeoJson);
        document
          .getElementById("download-btn")
          .addEventListener("click", downloadEnhancedGeoJson);
        document
          .getElementById("geojson-text")
          .addEventListener("input", function () {
            document.getElementById("process-btn").disabled =
              !this.value.trim().length;
          });
        document.querySelectorAll(".tab").forEach((tab) => {
          tab.addEventListener("click", function () {
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.remove("bg-red-800", "text-white"));
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.add("bg-red-200", "text-red-800"));
            document
              .querySelectorAll(".tab-content")
              .forEach((c) => c.classList.add("hidden"));
            this.classList.remove("bg-red-200", "text-red-800");
            this.classList.add("bg-red-800", "text-white");
            document
              .getElementById(this.dataset.tab)
              .classList.remove("hidden");
          });
        });
      }

      function handleFile(file) {
        if (
          !file ||
          (!file.name.endsWith(".geojson") && !file.name.endsWith(".json"))
        ) {
          alert("Please upload a valid GeoJSON file");
          return;
        }
        const reader = new FileReader();
        reader.onload = function (e) {
          document.getElementById("geojson-text").value = e.target.result;
          document.getElementById("process-btn").disabled = false;
        };
        reader.readAsText(file);
      }

      async function processGeoJson() {
        document.getElementById("loader").classList.remove("hidden");
        document.getElementById("process-btn").disabled = true;
        const text = document.getElementById("geojson-text").value.trim();
        if (!text) {
          alert("Please provide GeoJSON data");
          return;
        }
        try {
          originalGeoJson = JSON.parse(text);
        } catch (err) {
          alert("Invalid GeoJSON: " + err.message);
          document.getElementById("loader").classList.add("hidden");
          document.getElementById("process-btn").disabled = false;
          return;
        }
        processedGeoJson = JSON.parse(JSON.stringify(originalGeoJson));
        let features = [];
        if (processedGeoJson.type === "FeatureCollection")
          features = processedGeoJson.features;
        else if (processedGeoJson.type === "Feature")
          features = [processedGeoJson];
        else if (
          [
            "Point",
            "LineString",
            "Polygon",
            "MultiPoint",
            "MultiLineString",
            "MultiPolygon",
          ].includes(processedGeoJson.type)
        )
          features = [
            { type: "Feature", properties: {}, geometry: processedGeoJson },
          ];

        // Process only Polygon/MultiPolygon features
        for (let feature of features) {
          if (
            feature.geometry &&
            ["Polygon", "MultiPolygon"].includes(feature.geometry.type)
          ) {
            try {
              const res = await fetch(
                "https://disaster.ninja/active/api/polygon_details",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                  },
                  body: JSON.stringify({
                    type: "Feature",
                    properties: {},
                    geometry: feature.geometry,
                  }),
                }
              );
              if (!res.ok) throw new Error(`API error: ${res.status}`);
              const data = await res.json();
              if (!feature.properties) feature.properties = {};
              data.forEach((item) => {
                let key = item.name.toLowerCase().replace(/\s+/g, "_");
                if (item.name === "Population") {
                  const pop = item.text.match(/([0-9,]+) people/);
                  const area = item.text.match(/on ([0-9.]+) km2/);
                  feature.properties.population = pop
                    ? parseInt(pop[1].replace(/,/g, ""))
                    : 0;
                  feature.properties.area_km2 = area ? parseFloat(area[1]) : 0;
                  feature.properties.population_density =
                    feature.properties.area_km2 > 0
                      ? feature.properties.population /
                        feature.properties.area_km2
                      : 0;
                } else {
                  feature.properties[`${key}_percent`] = item.percentValue;
                }
              });
            } catch (err) {
              console.error(err);
              feature.properties.processing_error = err.message;
            }
          } else {
            feature.properties.processing_note =
              "Only Polygon/MultiPolygon processed";
          }
        }

        // Build the dropdown dynamically from union of property keys
        const keys = new Set();
        features.forEach((f) => {
          if (f.properties)
            Object.keys(f.properties).forEach((k) => keys.add(k));
        });
        const sel = document.getElementById("metric-selector");
        sel.innerHTML = "";
        keys.forEach((k) => {
          const opt = document.createElement("option");
          opt.value = k;
          opt.textContent = k.replace(/_/g, " ");
          sel.appendChild(opt);
        });
        currentMetric = keys.has("osm_gaps_percent")
          ? "osm_gaps_percent"
          : sel.options[0].value;
        sel.value = currentMetric;
        updateMap(processedGeoJson);
        updateTable(processedGeoJson);
        document.getElementById("download-btn").disabled = false;
        document.getElementById("loader").classList.add("hidden");
        document.getElementById("process-btn").disabled = false;
      }

      function getColor(value, min, max) {
        if (value == null || isNaN(value)) return "#CCCCCC";
        const norm = (value - min) / (max - min);
        return norm < 0.2
          ? "#FFEDA0"
          : norm < 0.4
          ? "#FEB24C"
          : norm < 0.6
          ? "#FD8D3C"
          : norm < 0.8
          ? "#FC4E2A"
          : "#BD0026";
      }

      function updateMap(geojson) {
        if (geoJsonLayer) map.removeLayer(geoJsonLayer);
        let feats =
          geojson.type === "FeatureCollection"
            ? geojson.features
            : geojson.type === "Feature"
            ? [geojson]
            : [{ type: "Feature", properties: {}, geometry: geojson }];
        let min = Infinity,
          max = -Infinity;
        feats.forEach((f) => {
          const val = f.properties && parseFloat(f.properties[currentMetric]);
          if (!isNaN(val)) {
            min = Math.min(min, val);
            max = Math.max(max, val);
          }
        });
        if (min === Infinity || max === -Infinity) {
          min = 0;
          max = 100;
        }
        const fc = { type: "FeatureCollection", features: feats };
        geoJsonLayer = L.geoJSON(fc, {
          style: (f) => {
            const val = f.properties && parseFloat(f.properties[currentMetric]);
            return {
              fillColor: getColor(val, min, max),
              weight: 2,
              opacity: 1,
              color: "white",
              dashArray: "3",
              fillOpacity: 0.7,
            };
          },
          onEachFeature: (f, layer) => {
            let popup = "<div>";
            for (const [key, value] of Object.entries(f.properties || {})) {
              popup += `<p><strong>${key.replace(
                /_/g,
                " "
              )}:</strong> ${value}</p>`;
            }
            popup += "</div>";
            layer.bindPopup(popup);
          },
        }).addTo(map);
        if (geoJsonLayer.getBounds().isValid())
          map.fitBounds(geoJsonLayer.getBounds());
        addLegend(min, max);
      }

      function addLegend(min, max) {
        if (map.legend) map.removeControl(map.legend);
        const legend = L.control({ position: "bottomright" });
        legend.onAdd = function () {
          const div = L.DomUtil.create(
            "div",
            "legend bg-white p-2 rounded shadow text-sm"
          );
          const step = (max - min) / 5,
            ranges = [
              min,
              min + step,
              min + step * 2,
              min + step * 3,
              min + step * 4,
            ];
          const colors = [
            "#FFEDA0",
            "#FEB24C",
            "#FD8D3C",
            "#FC4E2A",
            "#BD0026",
          ];
          div.innerHTML += `<h4 class="mb-2">${currentMetric
            .replace(/_/g, " ")
            .toUpperCase()}</h4>`;
          colors.forEach((c, i) => {
            const from =
              i === 0
                ? min.toLocaleString(undefined, { maximumFractionDigits: 2 })
                : ranges[i].toLocaleString(undefined, {
                    maximumFractionDigits: 2,
                  });
            const to =
              i < colors.length - 1
                ? ranges[i + 1].toLocaleString(undefined, {
                    maximumFractionDigits: 2,
                  })
                : max.toLocaleString(undefined, { maximumFractionDigits: 2 });
            div.innerHTML += `<i style="background:${c}"></i> ${
              currentMetric.includes("percent")
                ? from + "% – " + to + "%"
                : from + " – " + to
            }<br>`;
          });
          return div;
        };
        legend.addTo(map);
        map.legend = legend;
      }

      function updateTable(geojson) {
        const container = document.getElementById("table-container");
        let feats =
          geojson.type === "FeatureCollection"
            ? geojson.features
            : geojson.type === "Feature"
            ? [geojson]
            : [{ type: "Feature", properties: {}, geometry: geojson }];
        if (!feats.length) {
          container.innerHTML = "<p>No features found.</p>";
          return;
        }
        const keys = new Set();
        feats.forEach((f) => {
          if (f.properties)
            Object.keys(f.properties).forEach((k) => keys.add(k));
        });
        let html = `<table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Feature</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Geometry Type</th>`;
        [...keys]
          .sort()
          .forEach(
            (k) =>
              (html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">${k.replace(
                /_/g,
                " "
              )}</th>`)
          );
        html += `</tr></thead>
          <tbody class="bg-white divide-y divide-gray-200">`;
        feats.forEach((f, i) => {
          html += `<tr>
            <td class="px-6 py-4">${f.id || i + 1}</td>
            <td class="px-6 py-4">${f.geometry?.type || "N/A"}</td>`;
          [...keys]
            .sort()
            .forEach(
              (k) =>
                (html += `<td class="px-6 py-4">${
                  f.properties && f.properties[k] !== undefined
                    ? f.properties[k]
                    : ""
                }</td>`)
            );
          html += `</tr>`;
        });
        html += `</tbody></table>`;
        container.innerHTML = html;
      }

      function downloadEnhancedGeoJson() {
        if (!processedGeoJson) {
          alert("No processed GeoJSON available");
          return;
        }
        const blob = new Blob([JSON.stringify(processedGeoJson, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob),
          a = document.createElement("a");
        a.href = url;
        a.download = "processed_osm_completeness.geojson";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      document.addEventListener("DOMContentLoaded", () => {
        initMap();
        initDragAndDrop();
      });
    </script>
  </body>
</html>
