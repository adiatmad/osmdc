<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>OSM Completeness Helper - Fast & Interactive</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<style>
  .legend i { display: inline-block; width: 18px; height: 18px; margin-right: 8px; opacity: 0.7; }
  .highlight-row { background-color: #fffa65 !important; }
  .highlight-feature { weight: 4 !important; color: red !important; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #ccc; padding: 4px; font-size: 0.9rem; text-align: left; }
  th { background-color: #f0f0f0; }
</style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="max-w-4xl mx-auto p-5">
  <h1 class="text-center text-3xl font-bold text-red-900 mb-6">OSM Completeness Helper</h1>

  <!-- Step 1: Upload -->
  <div class="bg-white p-5 rounded-lg shadow mb-5">
    <h2 class="text-xl font-semibold mb-3">Step 1: Upload or Paste GeoJSON</h2>
    <div id="upload-container" class="border-2 border-dashed border-red-800 rounded-lg p-6 text-center bg-white mb-3">
      <p class="mb-2">Drag & drop your GeoJSON file here</p>
      <p class="mb-2">OR</p>
      <input type="file" id="file-input" accept=".geojson,.json" class="hidden" />
      <button id="file-select-btn" class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded mb-2">Select File</button>
      <p class="mb-2">OR paste GeoJSON text below:</p>
      <textarea id="geojson-text" placeholder="Paste your GeoJSON here..." class="w-full h-32 p-2 border border-gray-300 rounded mb-2 font-mono"></textarea>
    </div>

    <button id="split-btn" class="bg-blue-800 hover:bg-blue-700 text-white py-2 px-4 rounded mb-2 w-full">Split Multi-Areas → Single Areas</button>
    <button id="process-btn" class="bg-red-800 hover:bg-red-700 text-white py-2 px-4 rounded mb-2 w-full" disabled>Process GeoJSON</button>
    <button id="download-btn" class="bg-green-800 hover:bg-green-700 text-white py-2 px-4 rounded w-full" disabled>Download Processed GeoJSON</button>
    <div id="loader" class="w-8 h-8 border-4 border-gray-300 border-t-red-800 rounded-full animate-spin mx-auto hidden mt-2"></div>
  </div>

  <!-- Map & Table Tabs -->
  <div class="flex space-x-2 mb-4">
    <button class="tab active px-4 py-2 bg-red-800 text-white rounded-t" data-tab="map-tab">Map View</button>
    <button class="tab px-4 py-2 bg-red-200 text-red-800 rounded-t" data-tab="table-tab">Table View</button>
  </div>

  <div id="map-tab" class="tab-content">
    <div class="bg-white p-4 rounded-lg shadow mb-4 flex flex-col sm:flex-row items-center">
      <label for="metric-selector" class="mr-2 font-medium">Color Map By:</label>
      <select id="metric-selector" class="p-2 border border-gray-300 rounded mt-2 sm:mt-0"></select>
    </div>
    <div id="map" class="h-[500px] rounded-lg mb-4"></div>
    <div class="bg-white p-4 rounded-lg shadow text-center">
      <strong>Map Legend:</strong> Color shows the chosen metric (darker = higher value)
    </div>
  </div>

  <div id="table-tab" class="tab-content hidden">
    <div class="bg-white p-5 rounded-lg shadow">
      <h2 class="text-2xl font-semibold mb-4">GeoJSON Data Table</h2>
      <div id="table-container">
        <p>Process a GeoJSON file to see its data in a table here.</p>
      </div>
    </div>
  </div>

  <footer class="text-center mt-8 text-sm text-gray-600">
    Developed with ❤️ by <a href="https://github.com/kshitijrajsharma/" class="text-red-800 font-semibold" target="_blank">Kshitij Raj Sharma</a> & Disaster Ninja API
  </footer>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script>
let map, geoJsonLayer, originalGeoJson=null, processedGeoJson=null, currentMetric="osm_gaps_percent";
let originalFileName = "geojson";
let featureIdCounter = 0;

// ===== Split GeoJSON Multi → Single =====
function splitGeoJSONToSinglepart(geojson){
  if(!geojson) return geojson;
  let features=[];
  const addFeature=(feature)=>{
    if(!feature.geometry) return;
    switch(feature.geometry.type){
      case "MultiPolygon":
        feature.geometry.coordinates.forEach(coords=>features.push({type:"Feature", properties:{...feature.properties}, geometry:{type:"Polygon", coordinates:coords}, _fid: featureIdCounter++}));
        break;
      case "MultiLineString":
        feature.geometry.coordinates.forEach(coords=>features.push({type:"Feature", properties:{...feature.properties}, geometry:{type:"LineString", coordinates:coords}, _fid: featureIdCounter++}));
        break;
      case "GeometryCollection":
        feature.geometry.geometries.forEach(geom=>features.push({type:"Feature", properties:{...feature.properties}, geometry:geom, _fid: featureIdCounter++}));
        break;
      default:
        features.push({...feature, _fid: featureIdCounter++});
    }
  };
  if(geojson.type==="FeatureCollection") geojson.features.forEach(addFeature);
  else if(geojson.type==="Feature") addFeature(geojson);
  else features.push({type:"Feature", properties:{}, geometry:geojson, _fid: featureIdCounter++});
  return {type:"FeatureCollection", features};
}

// ===== Map init =====
function initMap() {
  map=L.map("map",{preferCanvas:true}).setView([20,0],2);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:'&copy; OpenStreetMap contributors'}).addTo(map);
  document.getElementById("metric-selector").addEventListener("change", function(){
    currentMetric=this.value;
    if(processedGeoJson) updateMap(processedGeoJson);
  });
}

// ===== Drag & Drop / Buttons =====
function initDragAndDrop(){
  const uploadArea=document.getElementById("upload-container");
  uploadArea.addEventListener("dragover", e=>{ e.preventDefault(); uploadArea.classList.add("bg-red-100","border-red-700"); });
  uploadArea.addEventListener("dragleave", e=>{ e.preventDefault(); uploadArea.classList.remove("bg-red-100","border-red-700"); });
  uploadArea.addEventListener("drop", e=>{ e.preventDefault(); uploadArea.classList.remove("bg-red-100","border-red-700"); handleFile(e.dataTransfer.files[0]); });

  document.getElementById("file-select-btn").addEventListener("click", ()=>document.getElementById("file-input").click());
  document.getElementById("file-input").addEventListener("change", e=>handleFile(e.target.files[0]));

  document.getElementById("split-btn").addEventListener("click", ()=>{
    if(!originalGeoJson) return alert("Please upload or paste your GeoJSON first.");
    processedGeoJson=splitGeoJSONToSinglepart(originalGeoJson);
    document.getElementById("geojson-text").value=JSON.stringify(processedGeoJson,null,2);
    alert("GeoJSON split into single areas successfully!");
    document.getElementById("process-btn").disabled=false;
  });

  document.getElementById("process-btn").addEventListener("click", processGeoJson);
  document.getElementById("download-btn").addEventListener("click", downloadEnhancedGeoJson);

  document.getElementById("geojson-text").addEventListener("input", function(){
    document.getElementById("process-btn").disabled = !this.value.trim().length;
  });

  document.querySelectorAll(".tab").forEach(tab=>{
    tab.addEventListener("click", function(){
      document.querySelectorAll(".tab").forEach(t=>{t.classList.remove("bg-red-800","text-white"); t.classList.add("bg-red-200","text-red-800");});
      document.querySelectorAll(".tab-content").forEach(c=>c.classList.add("hidden"));
      this.classList.remove("bg-red-200","text-red-800"); this.classList.add("bg-red-800","text-white");
      document.getElementById(this.dataset.tab).classList.remove("hidden");
    });
  });
}

// ===== Handle File Upload =====
function handleFile(file){
  if(!file || (!file.name.endsWith(".geojson") && !file.name.endsWith(".json"))) return alert("Please upload a valid GeoJSON file");
  originalFileName = file.name.replace(/\.[^/.]+$/,""); // remove extension
  const reader=new FileReader();
  reader.onload=e=>{
    originalGeoJson=JSON.parse(e.target.result);
    document.getElementById("geojson-text").value=JSON.stringify(originalGeoJson,null,2);
    document.getElementById("process-btn").disabled=false;
  };
  reader.readAsText(file);
}

// ===== Process GeoJSON (Parallel Batches) =====
async function processGeoJson(){
  if(!originalGeoJson) return alert("Please upload or paste your GeoJSON first.");
  document.getElementById("loader").classList.remove("hidden");
  document.getElementById("process-btn").disabled=true;

  processedGeoJson=processedGeoJson || splitGeoJSONToSinglepart(JSON.parse(JSON.stringify(originalGeoJson)));
  const features=processedGeoJson.features;

  const batchSize = 5;
  for(let i=0;i<features.length;i+=batchSize){
    const batch = features.slice(i,i+batchSize);
    await Promise.allSettled(batch.map(async feature=>{
      if(feature.geometry && ["Polygon","MultiPolygon"].includes(feature.geometry.type)){
        try{
          const res=await fetch("https://disaster.ninja/active/api/polygon_details",{
            method:"POST",
            headers:{"Content-Type":"application/json","Accept":"application/json"},
            body:JSON.stringify({type:"Feature",properties:{},geometry:feature.geometry})
          });
          if(!res.ok) throw new Error(`API error: ${res.status}`);
          const data=await res.json();
          if(!feature.properties) feature.properties={};
          data.forEach(item=>{
            let key=item.name.toLowerCase().replace(/\s+/g,"_");
            if(item.name==="Population"){
              const pop=item.text.match(/([0-9,]+) people/);
              const area=item.text.match(/on ([0-9.]+) km2/);
              feature.properties.population=pop?parseInt(pop[1].replace(/,/g,"")):0;
              feature.properties.area_km2=area?parseFloat(area[1]):0;
              feature.properties.population_density=feature.properties.area_km2>0?feature.properties.population/feature.properties.area_km2:0;
            } else feature.properties[`${key}_percent`]=item.percentValue;
          });
        } catch(err){ feature.properties.processing_error=err.message; console.error(err);}
      } else feature.properties.processing_note="Only Polygon/MultiPolygon processed";
    }));
  }

  // Build dropdown metric
  const keys=new Set(); features.forEach(f=>{ if(f.properties) Object.keys(f.properties).forEach(k=>keys.add(k)); });
  const sel=document.getElementById("metric-selector"); sel.innerHTML="";
  keys.forEach(k=>{ const opt=document.createElement("option"); opt.value=k; opt.textContent=k.replace(/_/g," "); sel.appendChild(opt); });
  currentMetric=keys.has("osm_gaps_percent")?"osm_gaps_percent":sel.options[0].value; sel.value=currentMetric;

  updateMap(processedGeoJson);
  updateTable(processedGeoJson);
  document.getElementById("download-btn").disabled=false;
  document.getElementById("loader").classList.add("hidden");
  document.getElementById("process-btn").disabled=false;
}

// ===== Map & Table Functions =====
function updateMap(geojson){
  if(geoJsonLayer) map.removeLayer(geoJsonLayer);

  // Compute min/max for current metric
  const vals = geojson.features.map(f=>f.properties?.[currentMetric] ?? 0);
  const minVal = Math.min(...vals), maxVal = Math.max(...vals);
  const getColor = v => {
    if(maxVal===minVal) return "#67000d";
    const t=(v-minVal)/(maxVal-minVal);
    return t>0.8?"#67000d":t>0.6?"#a50f15":t>0.4?"#cb181d":t>0.2?"#ef3b2c":"#fb6a4a";
  };

  geoJsonLayer = L.geoJSON(geojson, {
    renderer: L.canvas(),
    style: f=>({color:getColor(f.properties?.[currentMetric]??0), weight:2, fillOpacity:0.6}),
    onEachFeature: (feature, layer)=>{
      layer.bindPopup(Object.entries(feature.properties||{}).map(([k,v])=>`<strong>${k}:</strong> ${v}`).join("<br>"));

      layer.on("mouseover", ()=>{ 
        layer.setStyle({weight:4, color:"red"});
        const row=document.querySelector(`tr[data-fid='${feature._fid}']`);
        if(row) row.classList.add("highlight-row");
      });
      layer.on("mouseout", ()=>{ 
        layer.setStyle({weight:2, color:getColor(feature.properties?.[currentMetric]??0)});
        const row=document.querySelector(`tr[data-fid='${feature._fid}']`);
        if(row) row.classList.remove("highlight-row");
      });
      layer.on("click", ()=> map.fitBounds(layer.getBounds()));
    }
  }).addTo(map);

  map.fitBounds(geoJsonLayer.getBounds());
  addLegend();
}

function addLegend(){
  const existing=document.querySelector(".legend");
  if(existing) existing.remove();

  const legend=L.control({position:"bottomright"});
  legend.onAdd=()=>{ 
    const div=L.DomUtil.create("div","legend bg-white p-2 rounded shadow");
    div.innerHTML=`<i style="background:#fb6a4a"></i> Low<br>
                   <i style="background:#ef3b2c"></i> Low-Medium<br>
                   <i style="background:#cb181d"></i> Medium<br>
                   <i style="background:#a50f15"></i> Medium-High<br>
                   <i style="background:#67000d"></i> High`;
    return div;
  };
  legend.addTo(map);
}

function updateTable(geojson){
  const container=document.getElementById("table-container");
  if(!geojson||!geojson.features||geojson.features.length===0){ container.innerHTML="<p>No features to display.</p>"; return; }

  const keys=new Set();
  geojson.features.forEach(f=>Object.keys(f.properties||{}).forEach(k=>keys.add(k)));
  const columns=Array.from(keys);

  let html="<table><thead><tr>";
  columns.forEach(col=>html+=`<th>${col}</th>`);
  html+="</tr></thead><tbody>";

  geojson.features.forEach(f=>{
    html+=`<tr data-fid='${f._fid}'>`;
    columns.forEach(col=>html+=`<td>${f.properties?.[col]??""}</td>`);
    html+="</tr>";
  });
  html+="</tbody></table>";
  container.innerHTML=html;

  // Add hover/click interaction
  geojson.features.forEach(f=>{
    const row=document.querySelector(`tr[data-fid='${f._fid}']`);
    if(!row) return;
    row.addEventListener("mouseover", ()=>{ 
      geoJsonLayer.eachLayer(l=>{ if(l.feature._fid===f._fid) l.setStyle({weight:4,color:"red"}); });
    });
    row.addEventListener("mouseout", ()=>{ 
      geoJsonLayer.eachLayer(l=>{ if(l.feature._fid===f._fid) l.setStyle({weight:2,color:"#cb181d"}); }); 
      updateMap(geojson); // refresh style
    });
    row.addEventListener("click", ()=>{ 
      geoJsonLayer.eachLayer(l=>{ if(l.feature._fid===f._fid) map.fitBounds(l.getBounds()); });
    });
  });
}

// ===== Download =====
function downloadEnhancedGeoJson(){
  if(!processedGeoJson) return alert("No processed GeoJSON available");
  const blob=new Blob([JSON.stringify(processedGeoJson,null,2)],{type:"application/json"});
  const url=URL.createObjectURL(blob), a=document.createElement("a");
  a.href=url; a.download=originalFileName+"_processed.geojson";
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

document.addEventListener("DOMContentLoaded", ()=>{ initMap(); initDragAndDrop(); });
</script>
</body>
</html>
