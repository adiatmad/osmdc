// Compute scoring (hazard ignored completely)
if (enablePriority) {

  // Extract numeric arrays
  const popArr = features.map(f =>
    (f.properties && isFinite(f.properties.population)) ? +f.properties.population : NaN
  );

  const buildArr = features.map(f => {
    const p = f.properties || {};
    if (isFinite(p.osm_gaps_percent)) return +p.osm_gaps_percent;
    if (isFinite(p.unmapped_buildings_percent)) return +p.unmapped_buildings_percent;
    if (isFinite(p.buildings_percent)) return +p.buildings_percent;
    return NaN;
  });

  // Normalize
  const popNorm = normalizeArray(popArr);
  const buildNorm = normalizeArray(buildArr);

  const hasPop = popNorm.some(v => !isNaN(v));
  const hasBuild = buildNorm.some(v => !isNaN(v));

  // New weights â€” ONLY pop + building
  // 0.5 population + 0.5 building
  let w = { pop: 0.5, build: 0.5 };

  if (!hasPop && !hasBuild) {
    // no data at all
    features.forEach(f => {
      f.properties.priority_score = NaN;
      f.properties.priority_class = 'LOW';
    });
  } else {
    // Recalculate scores
    features.forEach((f, i) => {
      let score = 0;
      let contributed = 0;

      if (hasPop && !isNaN(popNorm[i])) {
        score += w.pop * popNorm[i];
        contributed += w.pop;
      }

      if (hasBuild && !isNaN(buildNorm[i])) {
        score += w.build * buildNorm[i];
        contributed += w.build;
      }

      if (contributed && contributed !== 1) score = score / contributed;

      f.properties.priority_score = isFinite(score) ? score : NaN;
    });

    // Classify
    const scores = features.map(f =>
      isFinite(f.properties.priority_score) ? f.properties.priority_score : NaN
    );
    const classes = quantileClass(scores);
    features.forEach((f, i) => {
      f.properties.priority_class = classes[i] || 'LOW';
    });
  }
}
