<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>OSM Completeness Helper — Priority System</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<style>
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .chip{display:inline-block;padding:4px 8px;border-radius:999px;font-size:0.85rem;margin-right:6px}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #e5e7eb;padding:6px;font-size:13px;text-align:left}
  th{background:#f9fafb}
  .legend i{display:inline-block;width:18px;height:18px;margin-right:8px;vertical-align:middle}
  .loading{display:inline-block;width:16px;height:16px;border:3px solid #eee;border-top-color:#ef4444;border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-left:8px}
  @keyframes spin{to{transform:rotate(360deg)}}
  .priority-1{background:#7f1d1d;color:white;padding:6px 8px;border-radius:6px}
  .priority-2{background:#c026d3;color:white;padding:6px 8px;border-radius:6px}
  .priority-3{background:#f97316;color:white;padding:6px 8px;border-radius:6px}
  .priority-4{background:#facc15;color:#111;padding:6px 8px;border-radius:6px}
  .priority-5{background:#10b981;color:white;padding:6px 8px;border-radius:6px}
</style>
</head>
<body class="bg-gray-50 text-gray-900">
<div class="max-w-6xl mx-auto p-6">
  <h1 class="text-2xl font-bold text-red-800 mb-4">OSM Completeness Helper — Priority System</h1>

  <div class="bg-white rounded shadow p-4 mb-4">
    <h2 class="font-semibold">What "priority" means (plain language)</h2>
    <p class="text-sm mt-2">Each area gets a <strong>priority</strong> from <code>1 (Very High)</code> to <code>5 (Very Low)</code>. The priority is computed from:</p>
    <ul class="list-disc pl-6 text-sm">
      <li><strong>Estimated missing buildings</strong> — how many buildings are likely missing (area × baseline building density × unmapped %).</li>
      <li><strong>Estimated population</strong> — either provided by the data, or estimated from population density × area.</li>
    </ul>
    <p class="text-sm mt-2">We multiply those two (missing × population) to get a raw impact score, then convert into priority groups (percentiles). This helps volunteers pick areas that maximize the number of people helped per mapper-hour.</p>
  </div>

  <!-- Controls -->
  <div class="bg-white rounded shadow p-4 mb-4">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div>
        <label class="font-semibold">Upload or paste GeoJSON</label>
        <div id="upload" class="mt-2 border-2 border-dashed border-gray-200 p-3 rounded text-center">
          <input id="file-input" type="file" accept=".geojson,.json" class="hidden" />
          <button id="btn-file" class="bg-red-700 text-white px-3 py-1 rounded">Choose file</button>
          <textarea id="geojson-text" placeholder="Or paste GeoJSON here" class="w-full h-28 mt-2 p-2 border rounded font-mono text-sm"></textarea>
        </div>
        <div class="flex gap-2 mt-3">
          <button id="btn-split" class="bg-blue-600 text-white px-3 py-2 rounded">Split → Singlepart</button>
          <button id="btn-process" class="bg-green-700 text-white px-3 py-2 rounded" disabled>Process (compute priority)</button>
        </div>
      </div>

      <div>
        <label class="font-semibold">Options</label>
        <div class="mt-2 text-sm">
          <label class="inline-flex items-center gap-2"><input type="checkbox" id="use-baseline" checked/> Use baseline building density</label>
          <div class="mt-2 text-xs text-gray-600">Baseline density (buildings/km²) <input id="baseline-density" type="number" value="300" class="border ml-2 p-1 w-24"/></div>
        </div>

        <div class="mt-4">
          <button id="btn-download" class="bg-indigo-700 text-white px-3 py-2 rounded w-full" disabled>Download Processed GeoJSON</button>
          <button id="btn-csv" class="bg-indigo-500 text-white px-3 py-2 rounded w-full mt-2" disabled>Export Priority CSV</button>
        </div>
      </div>

      <div>
        <label class="font-semibold">Quick stats</label>
        <div class="mt-2 text-sm">
          <div>Features: <span id="stat-features">0</span></div>
          <div>Processed: <span id="stat-processed">No</span></div>
        </div>
        <div class="mt-4">
          <label class="font-semibold">Legend</label>
          <div class="mt-2" id="legend-small">
            <div><span class="chip priority-1">1 Very High</span></div>
            <div class="mt-1"><span class="chip priority-2">2 High</span></div>
            <div class="mt-1"><span class="chip priority-3">3 Medium</span></div>
            <div class="mt-1"><span class="chip priority-4">4 Low</span></div>
            <div class="mt-1"><span class="chip priority-5">5 Very Low</span></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="flex gap-4">
    <div class="flex-1">
      <div id="map" class="h-[640px] rounded shadow"></div>
    </div>
    <div class="w-96">
      <div class="bg-white rounded shadow p-3 mb-3">
        <h3 class="font-semibold">Top priorities</h3>
        <div id="toplist" class="mt-2 text-sm">No data yet.</div>
      </div>
      <div class="bg-white rounded shadow p-3">
        <h3 class="font-semibold">Table (click row to zoom)</h3>
        <div id="table" style="max-height:420px;overflow:auto;font-size:13px">No data yet.</div>
      </div>
    </div>
  </div>

  <footer class="mt-6 text-xs text-gray-600">Priority computed as: estimated_missing_buildings × estimated_population, then converted to groups (1..5). See baseline density option to tune local conditions.</footer>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script>
let map, geoJsonLayer=null, originalGeoJson=null, processedGeoJson=null, featureIdCounter=0;

function init(){
  map = L.map('map').setView([2,117],5);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OSM'}).addTo(map);
  wireUI();
}

function wireUI(){
  document.getElementById('btn-file').addEventListener('click', ()=>document.getElementById('file-input').click());
  document.getElementById('file-input').addEventListener('change', e=>handleFile(e.target.files[0]));
  document.getElementById('btn-split').addEventListener('click', ()=>{
    if(!originalGeoJson) tryLoadTextarea();
    if(!originalGeoJson) return alert('No GeoJSON loaded');
    processedGeoJson = splitGeoJSONToSinglepart(originalGeoJson);
    document.getElementById('geojson-text').value = JSON.stringify(processedGeoJson,null,2);
    document.getElementById('stat-features').textContent = processedGeoJson.features.length;
    document.getElementById('btn-process').disabled = false;
  });

  document.getElementById('btn-process').addEventListener('click', async ()=>{
    document.getElementById('btn-process').disabled = true;
    const originalLabel = document.getElementById('btn-process').textContent;
    document.getElementById('btn-process').innerHTML = 'Working <span class="loading"></span>';
    try{
      if(!originalGeoJson) tryLoadTextarea();
      if(!originalGeoJson) throw new Error('No GeoJSON loaded');
      // default: work on singlepart copy (safer)
      processedGeoJson = splitGeoJSONToSinglepart(originalGeoJson);
      computePriority(processedGeoJson);
      renderAll(processedGeoJson);
      document.getElementById('stat-processed').textContent = 'Yes';
      document.getElementById('btn-download').disabled = false;
      document.getElementById('btn-csv').disabled = false;
    }catch(err){
      console.error(err);
      alert('Processing failed: '+err.message);
    }finally{
      document.getElementById('btn-process').disabled = false;
      document.getElementById('btn-process').textContent = originalLabel;
    }
  });

  document.getElementById('btn-download').addEventListener('click', ()=>{
    if(!processedGeoJson) return alert('No processed data');
    const name = (new Date()).toISOString().replace(/[:.]/g,'-');
    const filename = `processed_priority_${name}.geojson`;
    downloadFile(filename, JSON.stringify(processedGeoJson,null,2));
  });

  document.getElementById('btn-csv').addEventListener('click', ()=>{
    if(!processedGeoJson) return alert('No processed data');
    exportCSV(processedGeoJson);
  });
}

function tryLoadTextarea(){
  const txt = document.getElementById('geojson-text').value.trim();
  if(!txt) return;
  try{ originalGeoJson = JSON.parse(txt); }catch(e){ alert('Invalid JSON in textarea'); }
}

function handleFile(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = e=>{
    try{ originalGeoJson = JSON.parse(e.target.result); document.getElementById('geojson-text').value = JSON.stringify(originalGeoJson,null,2); document.getElementById('btn-process').disabled = false; document.getElementById('stat-features').textContent = (originalGeoJson.features||[]).length; }catch(err){ alert('Invalid GeoJSON'); }
  };
  reader.readAsText(file);
}

function splitGeoJSONToSinglepart(geojson){
  featureIdCounter = 0;
  if(!geojson) return null;
  const out = { type:'FeatureCollection', features:[] };
  const add = f=>{
    if(!f.geometry) return;
    const t = f.geometry.type;
    if(t === 'MultiPolygon'){
      f.geometry.coordinates.forEach(coords=>{
        out.features.push({ type:'Feature', properties: {...(f.properties||{})}, geometry: { type:'Polygon', coordinates: coords}, _fid: featureIdCounter++ });
      });
    } else {
      out.features.push({...f, _fid: featureIdCounter++});
    }
  };
  if(geojson.type === 'FeatureCollection') geojson.features.forEach(add);
  else if(geojson.type === 'Feature') add(geojson);
  return out;
}

// Priority computation
function computePriority(fc){
  if(!fc || !fc.features) throw new Error('Empty features');
  const baseline = safeNum(Number(document.getElementById('baseline-density').value) || 300);
  const useBaseline = document.getElementById('use-baseline').checked;

  const rawScores = [];
  fc.features.forEach(f=>{
    if(!f.properties) f.properties = {};
    // ensure area
    f.properties.area_km2 = safeNum(f.properties.area_km2 || estimateAreaKm2(f.geometry));
    f.properties.building_unmapped_percent = safeNum(f.properties.building_unmapped_percent || 0);
    // estimated missing buildings
    const density = useBaseline ? baseline : (safeNum(f.properties.building_density) || baseline);
    const estMissing = f.properties.area_km2 * density * (f.properties.building_unmapped_percent/100);
    f.properties.estimated_missing_buildings = Math.round(estMissing);
    // estimated population: use provided population, else pop_density * area, else fallback 1
    let pop = safeNum(f.properties.population);
    if(!pop){
      const pd = safeNum(f.properties.population_density);
      if(pd > 0) pop = pd * f.properties.area_km2;
    }
    if(!pop) pop = 1; // small fallback to avoid zeroing
    f.properties.estimated_population = Math.round(pop);
    // raw priority score
    const raw = f.properties.estimated_missing_buildings * f.properties.estimated_population;
    f.properties._priority_raw = raw;
    rawScores.push(raw);
  });

  // convert to percentiles and buckets
  rawScores.sort((a,b)=>a-b);
  const n = rawScores.length;
  fc.features.forEach(f=>{
    const raw = f.properties._priority_raw || 0;
    const idx = rawScores.indexOf(raw);
    // percentile (0..1)
    const p = (n <= 1) ? 0.5 : (idx / (n-1));
    // assign group: top 10% -> 1, 10-30% ->2, 30-60%->3, 60-90%->4, rest->5
    let priority = 5; let label = 'Very Low';
    if(p >= 0.9) { priority = 1; label='Very High'; }
    else if(p >= 0.7) { priority = 2; label='High'; }
    else if(p >= 0.4) { priority = 3; label='Medium'; }
    else if(p >= 0.1) { priority = 4; label='Low'; }
    else { priority = 5; label='Very Low'; }

    f.properties.priority = priority;
    f.properties.priority_label = `${priority} - ${label}`;
    // color hint for UI
    f.properties.priority_color = priorityColor(priority);
  });
}

function priorityColor(p){
  switch(p){
    case 1: return '#7f1d1d'; // very high (dark red)
    case 2: return '#c026d3'; // high (magenta)
    case 3: return '#f97316'; // medium (orange)
    case 4: return '#facc15'; // low (yellow)
    case 5: return '#10b981'; // very low (green)
    default: return '#9ca3af';
  }
}

function renderAll(fc){
  if(!fc) return;
  // remove old
  if(geoJsonLayer) map.removeLayer(geoJsonLayer);

  // draw with priority color
  geoJsonLayer = L.geoJSON(fc, {
    style: f=>({ color: f.properties.priority_color || '#9ca3af', weight:2, fillOpacity:0.6 }),
    onEachFeature: (feature, layer)=>{
      const p = feature.properties || {};
      const lines = [];
      lines.push(`<strong>Priority:</strong> ${p.priority_label || ''}`);
      lines.push(`<strong>Est missing buildings:</strong> ${p.estimated_missing_buildings || 0}`);
      lines.push(`<strong>Est population:</strong> ${p.estimated_population || 0}`);
      if(p.building_unmapped_percent !== undefined) lines.push(`<strong>Unmapped %:</strong> ${p.building_unmapped_percent}`);
      layer.bindPopup(lines.join('<br>'));
      layer.on('click', ()=>{ try{ map.fitBounds(layer.getBounds()); }catch(e){} });
    }
  }).addTo(map);

  try{ if(geoJsonLayer.getBounds && geoJsonLayer.getBounds().isValid()) map.fitBounds(geoJsonLayer.getBounds()); }catch(e){}

  // update table & toplist
  renderTable(fc);
  renderTopList(fc, 10);
}

function renderTable(fc){
  const container = document.getElementById('table');
  if(!fc || !fc.features || fc.features.length === 0){ container.innerHTML = '<p>No features</p>'; return; }
  // columns: fid, priority_label, estimated_missing_buildings, estimated_population, building_unmapped_percent, area_km2
  let html = '<table><thead><tr><th>fid</th><th>priority</th><th>missing_buildings</th><th>population</th><th>unmapped%</th><th>area_km2</th></tr></thead><tbody>';
  fc.features.forEach(f=>{
    const p = f.properties || {};
    html += `<tr data-fid="${f._fid}"><td>${f._fid}</td><td>${p.priority_label||''}</td><td>${p.estimated_missing_buildings||0}</td><td>${p.estimated_population||0}</td><td>${p.building_unmapped_percent||0}</td><td>${p.area_km2||0}</td></tr>`;
  });
  html += '</tbody></table>';
  container.innerHTML = html;
  // add click listeners to zoom
  container.querySelectorAll('tr[data-fid]').forEach(r=> r.addEventListener('click', ()=>{
    const fid = Number(r.getAttribute('data-fid'));
    geoJsonLayer.eachLayer(l=>{ if(l.feature._fid === fid) try{ map.fitBounds(l.getBounds()); }catch(e){} });
  }));
}

function renderTopList(fc, n=10){
  const div = document.getElementById('toplist');
  if(!fc) return; const arr = [...fc.features].sort((a,b)=> (b.properties._priority_raw||0) - (a.properties._priority_raw||0));
  const top = arr.slice(0,n);
  let html = '<ol class="pl-4">';
  top.forEach(f=>{ const p=f.properties; html += `<li style="margin-bottom:6px"><strong>${p.priority_label||''}</strong> — missing:${p.estimated_missing_buildings} pop:${p.estimated_population}</li>`; });
  html += '</ol>';
  div.innerHTML = html;
}

function downloadFile(name, content){
  const blob = new Blob([content], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}

function exportCSV(fc){
  const rows = [['fid','priority','priority_label','estimated_missing_buildings','estimated_population','building_unmapped_percent','area_km2']];
  fc.features.forEach(f=>{ const p=f.properties||{}; rows.push([f._fid,p.priority||'',p.priority_label||'',p.estimated_missing_buildings||0,p.estimated_population||0,p.building_unmapped_percent||0,p.area_km2||0]); });
  const csv = rows.map(r=> r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const name = `priority_list_${(new Date()).toISOString().replace(/[:.]/g,'-')}.csv`;
  const blob = new Blob([csv], { type: 'text/csv' }); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}

// helpers
function safeNum(x){ return (x===undefined||x===null||isNaN(Number(x)))?0:Number(x); }

function estimateAreaKm2(geometry){
  try{
    if(!geometry) return 0;
    const coords = (geometry.type==='Polygon') ? geometry.coordinates[0] : (geometry.type==='MultiPolygon' ? geometry.coordinates[0][0] : []);
    if(!coords || coords.length===0) return 0;
    let minLat=90,maxLat=-90,minLon=180,maxLon=-180;
    coords.forEach(c=>{ const lon=c[0], lat=c[1]; if(lat<minLat) minLat=lat; if(lat>maxLat) maxLat=lat; if(lon<minLon) minLon=lon; if(lon>maxLon) maxLon=lon; });
    const avgLat=(minLat+maxLat)/2; const latKm = 111.32; const lonKm = 111.32 * Math.cos(avgLat*Math.PI/180);
    const width = Math.max(0, (maxLon-minLon)*lonKm); const height = Math.max(0,(maxLat-minLat)*latKm);
    return Math.round(width*height*100)/100;
  }catch(e){ return 0; }
}

// CSV/export buttons wiring
document.addEventListener('click',(e)=>{
  if(e.target && e.target.id === 'btn-csv'){
    if(processedGeoJson) exportCSV(processedGeoJson);
  }
});

// init
init();
</script>
</body>
</html>
